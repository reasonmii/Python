
# 문제6 : 밭의비밀

sample = [
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0]
        ]

첫번째밭 = [
        [1, 0, 0, 0, 0],
        [0, 0, 1, 0, 1],
        [0, 0, 1, 0, 1],
        [0, 0, 1, 0, 1],
        [0, 0, 1, 0, 1]
        ]

두번째밭 = [
        [0, 0, 0, 0, 1],
        [0, 0, 0, 0, 3],
        [0, 0, 0, 0, 4],
        [0, 2, 0, 0, 2],
        [4, 5, 0, 2, 0]
        ]


### numpy 사용해서 행렬을 돌리고 더하는 방법 =========================================
# numpy : 행렬을 돌릴 때 매우 효율적이고 빠른 library
import numpy as np

# 두번째밭 : 시계 반대방향으로 90도 회전
np.rot90(두번째밭, 1)


# 행렬을 어떻게 해야 의미있는 값이 나올 수 있는지 탐색해보기
np.rot90(두번째밭, 1) + np.array(첫번째밭)
np.rot90(두번째밭, 1) - np.array(첫번째밭)
np.rot90(두번째밭, 1) * np.array(첫번째밭)
# 행렬의 곱
np.rot90(두번째밭, 1) @ np.array(첫번째밭)


# 정답찾기
정답 = np.rot90(두번째밭, 1) + np.array(첫번째밭)

# 8진법으로 바꾸기
int(''.join([str(i) for i in 정답[0]]), 8)
chr(int(''.join([str(i) for i in 정답[1]]), 8))

for k in range(5):
    print(chr(int(''.join([str(i) for i in 정답[k]]), 8)))

# 결과
# ✐
# C
# A
# V
# E


### numpy 없이 행렬을 돌리고 더하는 방법 =========================================
    
x = [[None]*5] * 5
x

# 행렬 주의
# 이렇게 넣으면 x[0][0], x[1][0], x[2][0], x[3][0], x[4][0] 값이 모두 10000으로 변함 
x[0][0] = 10000
x

''' 두 번째 행렬을 시계 반대방향으로 90도 회전하려면
# 두번째 밭에서 0,4 값은 0,0으로 가야 함
0, 4 -> 0, 0
1, 4 -> 0, 1
2, 4 -> 0, 2
3, 4 -> 0, 3
4, 4 -> 0, 4

0, 3 -> 1, 0
1, 3 -> 1, 1
2, 3 -> 1, 2
3, 3 -> 1, 3
4, 3 -> 1, 4

0, 2 -> 2, 0
1, 2 -> 2, 1
2, 2 -> 2, 2
3, 2 -> 2, 3
4, 2 -> 2, 4

0, 1 -> 3, 0
1, 1 -> 3, 1
2, 1 -> 3, 2
3, 1 -> 3, 3
4, 1 -> 3, 4

0, 0 -> 4, 0
1, 0 -> 4, 1
2, 0 -> 4, 2
3, 0 -> 4, 3
4, 0 -> 4, 4
'''

# 위와 같이 위치를 바꾸기 위한 방법
for i in range(len(두번째밭)):
    for j in range(len(두번째밭[0])):
        sample[i][j] = 두번째밭[j][len(두번째밭)-1-i]
        print(i, j)

sample

sample + 첫번째밭

for i in range(len(두번째밭)):
    for j in range(len(두번째밭[0])):
        sample[i][j] += 첫번째밭[i][j]

sample
